<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Markdown入门指南</title>
      <link href="/posts/2879.html"/>
      <url>/posts/2879.html</url>
      
        <content type="html"><![CDATA[<h1 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h1><p>Markdown是一种轻量级的标记语言，非常的简单，常用的符号不超过十个。</p><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>​    <code># 一级标题</code></p><p>​    <code>## 二级标题</code></p><p>​    <code>### 三级标题</code></p><p>​    总共有六个标题</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>​    列表分为有序列表和无序列表</p><ul><li>无序列表<br><code>-</code> 或 <code>*</code></li><li>有序列表<br><code>1. 2. 3.</code></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>​    直接在文本前面加 <code>&gt;</code></p><h2 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h2><ul><li>图片 <code>![]()</code></li><li>链接 <code>[]()</code></li></ul><h2 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h2><p>​    用两个<code>**</code>来表示粗体</p><p>​    用一个<code>*</code>来表示斜体</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><h2 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h2><p>​    用``来包裹起来</p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>​    三个<code>***</code> 来表示一个分割线</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git和github入门实践</title>
      <link href="/posts/f8de.html"/>
      <url>/posts/f8de.html</url>
      
        <content type="html"><![CDATA[<h2 id="Git与GitHub简介"><a href="#Git与GitHub简介" class="headerlink" title="Git与GitHub简介"></a>Git与GitHub简介</h2><h3 id="Git与GitHub的来历"><a href="#Git与GitHub的来历" class="headerlink" title="Git与GitHub的来历"></a>Git与GitHub的来历</h3><p>Linux 之父 Linus 在 1991 年创建开源的 Linux 操作系统之后，多年来依靠全世界广大热心志愿者的共同建设，经过长足发展，现已成为世界上最大的服务器系统。系统创建之初，代码贡献者将源码文件发送给 Linus，由其手动合并。这种方式维持多年后，代码量已经庞大到人工合并难以为继，于是深恶集中式版本控制系统的 Linus 选择了一个分布式商业版本控制系统 BitKeeper，不过 Linux 社区的建设者们可以免费使用它。BitKeeper 改变了 Linus 对版本控制的认识，同时 Linus 发现 BitKeeper 有一些不足，而且有个关键性的问题使之不能被广泛使用，就是不开源。</p><p>在 2005 年，BitKeeper 所在公司发现 Linux 社区有人企图破解它，BitKeeper 决定收回 Linux 社区的免费使用权。Linus 对此事调节数周无果，找遍了当时已知的各种版本控制系统，没有一个看上眼的，一怒之下决定自己搞一个。Linus 花了十天时间用 C 语言写好了一个开源的版本控制系统，就是著名的 Git。</p><p>2007 年旧金山三个年轻人觉得 Git 是个好东西，就搞了一个公司名字叫 GitHub，第二年上线了使用 Ruby 编写的同名网站 GitHub，这是一个基于 Git 的免费代码托管网站（有付费服务）。十年间，该网站迅速蹿红，击败了实力雄厚的 Google Code，成为全世界最受欢迎的代码托管网站。2018 年 6 月，GitHub 被财大气粗的 Microsoft 收购。2019 年 1 月 GitHub 宣布用户可以免费创建私有仓库。根据 2018 年 10 月的 GitHub 年度报告显示，目前有 3100 万开发者创建了 9600 万个项目仓库，有 210 万企业入驻。</p><h3 id="Git是用来干嘛的"><a href="#Git是用来干嘛的" class="headerlink" title="Git是用来干嘛的?"></a>Git是用来干嘛的?</h3><p>用来版本控制。通常我们修改了代码以后，发布新的版本以后，老版本是不可逆的，甚至多次修改可能会造成文件的混乱。这时，我们可以使用Git来进行控制，它可以方便的查看不同版本的不同之处，可以回退到老版本上。</p><h3 id="在GitHub上创建仓库"><a href="#在GitHub上创建仓库" class="headerlink" title="在GitHub上创建仓库"></a>在GitHub上创建仓库</h3><p>先要在GitHub上注册个人账户并登录。登录后在个人主页的右上角点击 <strong>New repository</strong>创建新的仓库。</p><p>填写<strong>Repository name</strong>后点击<strong>Create repository</strong></p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>在Windows系统，直接下载安装<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">GIt</a></p><h3 id="克隆GitHub上的仓库到本地"><a href="#克隆GitHub上的仓库到本地" class="headerlink" title="克隆GitHub上的仓库到本地"></a>克隆GitHub上的仓库到本地</h3><p>在仓库的主目录下，有一个隐藏的<code>.git</code>目录，它里面包含了仓库的全部信息，删掉这个目录，仓库就会变成普通的目录。使用命令行进入后，会发现出现(master),它就是当前所在的分支名。</p><p>当我们在GitHub上创建一个仓库时，同时生成了仓库的默认主机名origin,并创建了默认分钟master。GitHub可以看作是免费的Git服务器，在GitHub上创建仓库，会自动生成一个仓库地址，主机就是指代这个仓库。可通过执行<code>git remote -v</code>命令可以查看本地仓库所关联的远程仓库信息。</p><p>Git 要求对本地仓库关联的每个远程主机都必须指定一个主机名（默认为origin），用于本地仓库识别自己关联的主机，<code>git remote</code> 命令就用于管理本地仓库所关联的主机，一个本地仓库可以关联任意多个主机（即远程仓库）。</p><p>克隆远程仓库到本地时，还可以使用 <code>-o</code> 选项修改主机名，在地址后面加上一个字段作为本地仓库的主目录名。</p><p>常用命令<code>git init</code> ，它会把当前所在目录变成一个本地仓库，因为有GitHub,这个命令我们使用的次数应该为零。</p><h2 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h2><h3 id="Git仓库的三大区域"><a href="#Git仓库的三大区域" class="headerlink" title="Git仓库的三大区域"></a>Git仓库的三大区域</h3><p>Git本地仓库有三大区域：工作区、暂存区、版本区。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://images2015.cnblogs.com/blog/809218/201606/809218-20160604213850274-1309981476.jpg" alt="img"></p><ul><li>工作区(workspace): 逻辑上是本地计算机，还没添加到repository的状态。</li><li>暂存区(stage): 即版本库中的stage,修改已经添加进repository，但是还没有作为commit提交，类似于缓存。</li><li>版本区(local repository),本地的版本区，到这一步，才算是成功的生成了一个新的版本。</li><li>远程仓库(Remote repository)</li></ul><h3 id="一次完成的修改、提交、推送操作"><a href="#一次完成的修改、提交、推送操作" class="headerlink" title="一次完成的修改、提交、推送操作"></a>一次完成的修改、提交、推送操作</h3><h4 id="简单来说"><a href="#简单来说" class="headerlink" title="简单来说"></a>简单来说</h4><p>第一步，用<code>git add</code>告诉Git,把文件添加到仓库中</p><p>第二步，用<code>git commit</code>告诉Git,把文件提交到仓库中</p><h4 id="具体来说"><a href="#具体来说" class="headerlink" title="具体来说"></a>具体来说</h4><p>首先，进入仓库主目录，执行git status查看整个仓库的状态。</p><p>当对文件进行增删改操作时，命令行会出现一个*星号。这表示工作区或暂存区有变化。</p><p>使用<code>git add [文件名]</code>命令跟踪此新建文件，即把新增文件添加到暂存区，以备提交。如果对多个文件或目录进行了增删改，可以使用<code>git add .</code>命令全部添加到暂存区。(当我们修改了工作区，git add命令是将这些修改田间到暂存区，暂存区记录的只是修改，如果要撤销暂存区的修改，执行<code>git reset -- [文件名]</code>或<code>git rm -- cached [文件名]</code> )</p><p>使用<code>git diff</code>，可以用来查看工作区被跟踪的文件的修改详情。使用git diff –cached查看暂存区的全部修改。</p><p>接下来，执行<code>git commit</code>命令，把暂存区的修改提交到版本区，生成一个新的版本。</p><p><code>git log</code> 用来查看版本区的提交历史记录。<code>git log [分支名]</code> 查看某分支的提交历史，不写分支名查看当前所在分支。<code>git log --oneline</code> 一行显示提交历史。<code>git log -n</code>其中n是数字，查看最近n个提交。<code>git log --author [贡献者名字]</code>查看指定贡献者的提交记录。<code>git log --graph</code>图示法显示提交历史。</p><p>接下来需要对Git进行一些本地配置。<code>git config -l user.email '注册邮箱'</code> <code>git config -l user.name</code> 完成后，系统会自动生成Git的配置文件。.gitconfig</p><p>提交暂存区的修改 <code>git commit -m '备注'</code> 提交后，暂存区的修改会被清空，执行<code>git log</code>可查看提交记录，其中有一个十六位的序列号为提交版本号。</p><p><code>git branch -avv</code> 查看所有的分支信息。会显示的信息为，开头的型号表示当前所在的分支，后面加的是版本号，再后为跟踪的远程分支的名字。最后一项是提交时填写的备注信息。</p><p>最后一个环节为，将本地新增的提交推送到GitHub远程仓库种，命令为<code>git push</code> ，执行完成后，可以通过<code>git branch -avv</code>查看分支情况。</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><h4 id="简单来说-1"><a href="#简单来说-1" class="headerlink" title="简单来说"></a>简单来说</h4><p>第一步，使用<code>git log</code>查看历史的版本号</p><p>第二步，使用<code>git reset --hard [版本号或者是^]</code>回退版本</p><p>可以使用<code>git reflog</code>来查看每一次的命令，从而找到刚才回退前的版本号，从而实现可再回到新的版本上。</p><h4 id="具体来说-1"><a href="#具体来说-1" class="headerlink" title="具体来说"></a>具体来说</h4><p>首先执行<code>git reset --soft HEAD^</code> 撤销最近的一次提交，将修改还原到暂存区。<code>--soft</code>表示软退回，对应的还有<code>--hard</code>硬退回，后面会讲到。<code>HEAD</code>表示撤回一次提交，<code>HEAD^^</code>表示撤销两次提交，撤销n次提交可以简写为<code>HEAD~n</code>。软退回一个提交后执行<code>git branch -avv</code>命令查看分支信息，然后可以看到本地仓库的master分支的版本号已经发生了变化，变成了前一个提交的版本号。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><h4 id="对工作区的撤销"><a href="#对工作区的撤销" class="headerlink" title="对工作区的撤销"></a>对工作区的撤销</h4><p><code>git checkout -- file</code> 可以丢弃工作区的修改，使它回到最近的一个<code>git commit</code>或<code>git add</code>时的状态</p><h4 id="对暂存区的撤销"><a href="#对暂存区的撤销" class="headerlink" title="对暂存区的撤销"></a>对暂存区的撤销</h4><p><code>git reset HEAD &lt;file&gt;</code> 把暂存区的修改撤销掉，重新放回工作区</p><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><h3 id="GitHub基本配置"><a href="#GitHub基本配置" class="headerlink" title="GitHub基本配置"></a>GitHub基本配置</h3><p>第一步：创建SSH Key。<code>ssh-keygen -t rsa -C "youremail@example.com"</code> 。在用户主目录下找到<code>.ssh</code>隐藏文件夹。其中有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，<code>id_rsa</code>为私钥，<code>id_rsa.pub</code>为公钥。</p><p>第二步：登录GitHub，打开Account Setting，添加SSH Key，将公钥内容添加到里面。</p><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>第一步：登录GitHub，在右上角选择<code>Create a new repo</code>,新建一个仓库。</p><p>第二步：与本地仓库进行关联，在本地仓库运行<code>git remote add origin [地址]</code> 添加后，远程库的名字就叫origin</p><p>第三步：将本地仓库的内容推送到远程仓库中。<code>git push -u origin master</code> 第一次推动master分支时，加上-u参数，目的是将本地master 和远程的master进行关联。以后在进行推送时，只需要输入<code>git push origin master</code></p><h3 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h3><p><code>git clone [地址]</code> 从远程仓库中将代码克隆下来</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p><p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>第一步：创建dev分支，并切换到dev分支 <code>git checkout -b dev</code> 其中<code>-b</code>是用来创建分支的。</p><p>第二步：使用<code>git branch</code>会列出所有的分支，当前分支前面会有一个星号。</p><p>第三步：合并分支。使用<code>git merge [分支名]</code> 将指定分支合并到当前分支。</p><p>第四步：删除分支。使用<code>git checkout -d dev</code> 删除分支</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
