<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux基础入门（二）-vim基础入门</title>
      <link href="/posts/87fe.html"/>
      <url>/posts/87fe.html</url>
      
        <content type="html"><![CDATA[<h2 id="Vim模式"><a href="#Vim模式" class="headerlink" title="Vim模式"></a>Vim模式</h2><h3 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h3><p>​    在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。</p><h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><p>​    在这个模式中，大多数按键都会向文本缓冲中插入文本。在普通模式下按<code>i</code>进入，<code>esc</code>退出。</p><h3 id="可视模式"><a href="#可视模式" class="headerlink" title="可视模式"></a>可视模式</h3><p>​    这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。</p><h3 id="选择模式"><a href="#选择模式" class="headerlink" title="选择模式"></a>选择模式</h3><p>​    这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。</p><h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><p>​    在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（<code>:</code>键），搜索（<code>/</code>和<code>?</code>键）或者过滤命令（<code>!</code>键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。</p><p>我们常用的是普通模式、插入模式、命令行模式。</p><h2 id="模式操作"><a href="#模式操作" class="headerlink" title="模式操作"></a>模式操作</h2><h3 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h3><p>​    vim启动时为普通模式，当在插入模式或命令行模式时按住<code>esc</code>可退出进入普通模式；普通模式下按<code>i</code>进入插入模式；普通模式下按<code>:</code>进入命令行模式；在命令行模式下输入:<code>wq 回车</code> 会保存并退出vim。</p><h3 id="普通模式-1"><a href="#普通模式-1" class="headerlink" title="普通模式"></a>普通模式</h3><h4 id="游标移动"><a href="#游标移动" class="headerlink" title="游标移动"></a>游标移动</h4><table><thead><tr><th align="center">按键</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">h</td><td align="center">左</td></tr><tr><td align="center">l</td><td align="center">右</td></tr><tr><td align="center">j</td><td align="center">下</td></tr><tr><td align="center">l</td><td align="center">上</td></tr><tr><td align="center">w</td><td align="center">移动到下一个单词</td></tr><tr><td align="center">b</td><td align="center">移动到上一个单词</td></tr></tbody></table><h4 id="删除文本"><a href="#删除文本" class="headerlink" title="删除文本"></a>删除文本</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">删除游标所在字符</td></tr><tr><td align="center">X</td><td align="center">删除游标所在前一个字符</td></tr><tr><td align="center">Delete</td><td align="center">同x</td></tr><tr><td align="center">dd</td><td align="center">删除整行</td></tr><tr><td align="center">dw</td><td align="center">删除一个单词</td></tr><tr><td align="center">d$或D</td><td align="center">删除至行尾</td></tr><tr><td align="center">d^</td><td align="center">删除至行首</td></tr><tr><td align="center">dG</td><td align="center">删除到文档结尾处</td></tr><tr><td align="center">d1G</td><td align="center">删除至文档首部</td></tr><tr><td align="center">数字dd</td><td align="center">删除指定行数</td></tr></tbody></table><h4 id="重复命令"><a href="#重复命令" class="headerlink" title="重复命令"></a>重复命令</h4><p>在普通模式下 <code>.</code>表示重复上一次的命令操作</p><h4 id="游标快速移动"><a href="#游标快速移动" class="headerlink" title="游标快速移动"></a>游标快速移动</h4><ul><li>行间跳转</li></ul><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">nG</td><td align="center">游标移动到第n行</td></tr><tr><td align="center">gg</td><td align="center">游标移动到第一行</td></tr><tr><td align="center">G</td><td align="center">游标移动到最后一行</td></tr></tbody></table><ul><li><p>行内跳转</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">w</td><td align="center">到下一个单词的开头</td></tr><tr><td align="center">e</td><td align="center">到当前单词的结尾</td></tr><tr><td align="center">b</td><td align="center">到前一个单词的开头</td></tr><tr><td align="center">ge</td><td align="center">到前一个单词的结尾</td></tr><tr><td align="center">0或^</td><td align="center">到行头</td></tr><tr><td align="center">$</td><td align="center">到行尾</td></tr><tr><td align="center">f&lt;字母&gt;</td><td align="center">向后搜索，并跳转到第一个匹配的位置</td></tr><tr><td align="center">F&lt;字母&gt;</td><td align="center">向前搜索，并跳转到第一个匹配的位置</td></tr></tbody></table></li></ul><h4 id="复制、剪切、粘贴"><a href="#复制、剪切、粘贴" class="headerlink" title="复制、剪切、粘贴"></a>复制、剪切、粘贴</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">yy</td><td align="center">复制游标所在的整行(3yy表示复制3行)</td></tr><tr><td align="center">y^</td><td align="center">复制至行首</td></tr><tr><td align="center">y$</td><td align="center">复制至行尾</td></tr><tr><td align="center">yw</td><td align="center">复制一个单词</td></tr><tr><td align="center">y2w</td><td align="center">复制两个单词</td></tr><tr><td align="center">yG</td><td align="center">复制至文本末</td></tr><tr><td align="center">y1G</td><td align="center">复制至文本开头</td></tr><tr><td align="center">p</td><td align="center">粘贴至光标后</td></tr><tr><td align="center">P</td><td align="center">粘贴至光标前</td></tr><tr><td align="center">dd</td><td align="center">剪切</td></tr><tr><td align="center">ddp</td><td align="center">快速交换光标所在行与下行</td></tr></tbody></table><h3 id="插入模式-1"><a href="#插入模式-1" class="headerlink" title="插入模式"></a>插入模式</h3><h4 id="进入插入模式"><a href="#进入插入模式" class="headerlink" title="进入插入模式"></a>进入插入模式</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">在当前光标处进行编辑</td></tr><tr><td align="center">I</td><td align="center">在行首插入</td></tr><tr><td align="center">A</td><td align="center">在行末插入</td></tr><tr><td align="center">a</td><td align="center">在光标后插入编辑</td></tr><tr><td align="center">o</td><td align="center">在当前行后插入一个新行</td></tr><tr><td align="center">O</td><td align="center">在当前行前插入一个新行</td></tr><tr><td align="center">cw</td><td align="center">替换从光标所在位置后到一个单词结尾的字符</td></tr></tbody></table><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h4 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h4><p><code>:w</code></p><h4 id="退出vim"><a href="#退出vim" class="headerlink" title="退出vim"></a>退出vim</h4><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">:q!</td><td align="center">强制退出</td></tr><tr><td align="center">:q</td><td align="center">退出</td></tr><tr><td align="center">:wq!</td><td align="center">强制保存并退出</td></tr><tr><td align="center">:w &lt;文件路径&gt;</td><td align="center">另存为</td></tr><tr><td align="center">:saveas 文件路径</td><td align="center">另存为</td></tr><tr><td align="center">:x</td><td align="center">保存并退出</td></tr><tr><td align="center">:wq</td><td align="center">保存并退出</td></tr></tbody></table><p>在普通模式下按<code>Shift + zz</code> 即可保存退出vim</p><h4 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h4><p><code>:set nu</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础入门（一）-常用命令</title>
      <link href="/posts/386.html"/>
      <url>/posts/386.html</url>
      
        <content type="html"><![CDATA[<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table><thead><tr><th align="center">按键</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">Tab</td><td align="center">自动补全</td></tr><tr><td align="center">Ctrl + c</td><td align="center">终止程序</td></tr><tr><td align="center">Ctrl + d</td><td align="center">键盘输入结束或退出终端</td></tr><tr><td align="center">Ctrl + s</td><td align="center">暂停当前程序，暂停后按任意键恢复运行</td></tr><tr><td align="center">Ctrl + z</td><td align="center">将当前程序放到后台运行，回复到前台为命令fg</td></tr><tr><td align="center">Ctrl + a</td><td align="center">将光标移至输入行头</td></tr><tr><td align="center">Ctrl + e</td><td align="center">将光标移至输入行末</td></tr><tr><td align="center">Ctrl + k</td><td align="center">删除从光标所在位置到行末</td></tr><tr><td align="center">Alt + Backspace</td><td align="center">向前删除一个单词</td></tr><tr><td align="center">Shift + PgUp</td><td align="center">将终端显示向上滚动</td></tr><tr><td align="center">Shift + PgDn</td><td align="center">将终端显示向下滚动</td></tr></tbody></table><h2 id="常用通配符"><a href="#常用通配符" class="headerlink" title="常用通配符"></a>常用通配符</h2><table><thead><tr><th align="center">字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">匹配0或多个字符</td></tr><tr><td align="center">?</td><td align="center">匹配任意一个字符</td></tr><tr><td align="center">[list]</td><td align="center">匹配list中的任意单一字符</td></tr><tr><td align="center">[^list]</td><td align="center">匹配除list中的任意单一字符以外的字符</td></tr><tr><td align="center">[c1-c2]</td><td align="center">匹配c1-c2中的任意单一字符:如[0-9]</td></tr><tr><td align="center">{string,string2}</td><td align="center">匹配string1或string2其一字符串</td></tr><tr><td align="center">{c1..c2}</td><td align="center">匹配c1-c2中全部字符,如{1..10}</td></tr></tbody></table><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><p><code>sudo adduser demo</code></p><h3 id="切换登录用户"><a href="#切换登录用户" class="headerlink" title="切换登录用户"></a>切换登录用户</h3><p><code>su -l demo</code></p><h3 id="查看当前用户"><a href="#查看当前用户" class="headerlink" title="查看当前用户"></a>查看当前用户</h3><p><code>whoami</code></p><h3 id="退出当前用户"><a href="#退出当前用户" class="headerlink" title="退出当前用户"></a>退出当前用户</h3><p><code>exit</code></p><h3 id="查看当前用户所在的用户组"><a href="#查看当前用户所在的用户组" class="headerlink" title="查看当前用户所在的用户组"></a>查看当前用户所在的用户组</h3><p><code>groups demo</code><br>如果在创建用户的时候不指定用户组，系统会自动创建一个与用户同名的用户组</p><h3 id="将其他用户加入sudo用户组"><a href="#将其他用户加入sudo用户组" class="headerlink" title="将其他用户加入sudo用户组"></a>将其他用户加入sudo用户组</h3><p><code>sudo usermod -G sudo demo</code></p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p><code>sudo deluser demo--remove-home</code>  其中的<code>--remove-home</code> 是在删除用户是将该用户的工作目录一并删除。</p><h3 id="删除用户组"><a href="#删除用户组" class="headerlink" title="删除用户组"></a>删除用户组</h3><p><code>groupdel</code></p><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><h3 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h3><p>​    <code>ls -l</code> 显示文件详细内容 <code>文件类型和权限 + 链接数 + 所有者 + 文件大小 + 最后修改时间 + 文件名</code></p><ul><li><p>文件类型</p><p>d: 目录、l: 软链接、b: 块设备、c: 字符设备、s: socket、p: 管道</p></li></ul><ul><li><p>文件权限<br>r: 允许读、w: 允许写、x: 允许执行 其中有三组分别为这个文件拥有者、所属用户组、其他用户具有的权限</p></li><li><p>链接数<br>链接到该文件所在的inode结点的文件名的数目</p></li></ul><h3 id="变更文件所有者"><a href="#变更文件所有者" class="headerlink" title="变更文件所有者"></a>变更文件所有者</h3><p><code>sudo chown 用户名 文件名</code></p><h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p>用两种形式</p><ul><li>二进制形式<br>文件的读写执行对应的字母为rwx, 以二进制表示就是111，对应十进制就是7，三组就是777，所以修改权限的时候可以采用<code>chmod 600 文件名</code></li><li>加减赋值操作<br>g、o、u分别表示group、others、user，+、-分别表示增加和去掉相应的权限<br><code>chmod go-rw 文件名</code></li></ul><h2 id="目录结构及文件基本操作"><a href="#目录结构及文件基本操作" class="headerlink" title="目录结构及文件基本操作"></a>目录结构及文件基本操作</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>​    Linux 是以树形目录结构的形式来构建整个系统的</p><p>​    </p><table><thead><tr><th align="center">目录</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">bin</td><td align="center">一般用户可用，启动时会用到的命令，即在文件系统没有被挂载时，也能够使用的命令</td></tr><tr><td align="center">boot</td><td align="center">grub(开机设置相关文件)内核文件(vmlinuz)</td></tr><tr><td align="center">dev</td><td align="center">设备文件</td></tr><tr><td align="center">etc</td><td align="center">rc.d(用于存放不能运行等级的启动脚本的链接文件)</td></tr><tr><td align="center">home</td><td align="center">用户家目录</td></tr><tr><td align="center">lib</td><td align="center">用于存放程序的动态库和模块文件</td></tr><tr><td align="center">media</td><td align="center">用于挂在本地磁盘或其他存储设备</td></tr><tr><td align="center">mnt</td><td align="center">用于挂在其他临时文件系统</td></tr><tr><td align="center">opt</td><td align="center">发行版附加的一些软件包</td></tr><tr><td align="center">root</td><td align="center">root用户家</td></tr><tr><td align="center">sbin</td><td align="center">这里面很多只能是root用户才能执行的命令，一些系统进行更新，备份，还原和开关机用到命令</td></tr><tr><td align="center">srv</td><td align="center">存放服务进程所需的数据文件和一些服务的执行脚本</td></tr><tr><td align="center">tmp</td><td align="center">存放各种临时文件</td></tr><tr><td align="center">usr</td><td align="center">bin(非必要可执行文件；面向所有的用户)<br>include(标准包含头文件)<br>lib(/usr/bin/和/usr/sbin/中二进制文件内容)<br>local(本地数据)<br>share(体系结构无关的共享数据)<br>sbin(非必要的系统二进制文件)<br>src(源代码)</td></tr><tr><td align="center">var</td><td align="center">变量文件-在正常运行的系统中其内容不断变化的文件，如日志，脱机文件和临时电子邮件文件。</td></tr></tbody></table><p>将目录化为为四种交互作用的形态</p><table><thead><tr><th align="center"></th><th align="center">可分享的</th><th align="center">不可分享的</th></tr></thead><tbody><tr><td align="center">不可变的</td><td align="center">/usr(软件放置处)<br>/opt(第三方软件)</td><td align="center">/etc(配置文件)<br>/boot(开机及内核文件)</td></tr><tr><td align="center">可变动的</td><td align="center">/var/mail(用户邮件信箱)<br>/var/news(新闻组)</td><td align="center">/var/run(程序相关)<br>/var/lock(文件锁相关)</td></tr></tbody></table><h3 id="目录路径"><a href="#目录路径" class="headerlink" title="目录路径"></a>目录路径</h3><table><thead><tr><th align="center">..</th><th align="center">表示上一级目录</th></tr></thead><tbody><tr><td align="center">.</td><td align="center">表示当前目录</td></tr><tr><td align="center">-</td><td align="center">表示上一次所在目录</td></tr><tr><td align="center">~</td><td align="center">表示当前用户的home目录</td></tr></tbody></table><h3 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h3><ul><li><p>新建空白文件<br><code>touch 文件名</code></p></li><li><p>新建目录<br><code>mkdir 目录名</code> 加上<code>-p</code>参数可以创建一个多级目录</p></li><li><p>复制文件<br><code>cp 要复制的文件 复制到的目录</code></p></li><li><p>复制目录<br><code>cp -r 要复制的目录 复制到的目录</code></p></li><li><p>删除文件<br><code>rm 文件名</code> <code>-f</code>可删除只读文件 </p></li><li><p>删除目录<br><code>rm -r 目录名</code> </p></li><li><p>移动文件<br><code>mv 源目录文件 目的目录</code> </p></li><li><p>重命令文件<br><code>mv 旧文件名 新的文件名</code></p></li><li><p>批量重命令<br>需要先安装 <code>sudo apt install rename</code></p><p><code>rename 正则表达式</code></p></li><li><p>查看文件<br><code>cat 文件名</code> 将文件内容打印到终端 加上 <code>-n</code> 显示行数<br><code>tac 文件名</code> 倒序显示内容<br><code>nl 文件名</code> 添加行数并打印<br><code>head 文件名</code> 查看文件前十行 <code>-n 行数</code> 查看规定行数<br><code>tail 文件名</code> 查看文件最后十行 <code>-n 行数</code> 查看规定行数 <code>-f</code> 不断读取文件最后几行的内容</p></li><li><p>查看文件类型<br><code>file 文件名</code></p></li></ul><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>创建<br><code>declare tmp</code> 使用等号赋值(注意等号两边不能有空格)</li><li>读取<br><code>echo $tmp</code> $表示引用一个变量的值</li></ul><h3 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h3><p>​    环境变量是在操作系统中一个具有特定名字的对象，它包含了一个或多个应用程序将使用到的信息。Linux是一个多用户的操作系统，每个用户登录系统时都会有一个专用的运行环境，通常情况下每个用户的默认的环境都是相同的。这个默认环境就是一组环境变量的定义。每个用户都可以通过修改环境变量的方式对自己的运行环境进行配置。</p><table><thead><tr><th align="center">命令</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">set</td><td align="center">显示当前Shell所有的变量，包括内建环境变量、用户自定义变量、导出的环境变量</td></tr><tr><td align="center">env</td><td align="center">显示与当前用户相关的环境变量，还可以让命令在指定环境中运行</td></tr><tr><td align="center">export</td><td align="center">显示从Shell中导出成环境变量的变量，也能通过它将自定义变量导出为环境变量</td></tr></tbody></table><p>​    当关闭或者关闭当前shell之后，环境变量就会丢失。这时可以设置环境变量为永久生效。</p><p>​    <code>/etc/bashrc</code>存放shell变量；<code>/etc/profile</code>存放环境变量(对所有用户生效)；每个用户目录下有一个<code>.profile</code>文件(只对当前用户永久生效)</p><h2 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h2><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p>​    只能搜索二进制文件，帮助文件、源代码文件</p><h3 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h3><p>​    需要先安装 <code>apt install locate</code> 再执行<code>updatedb</code>  <code>-c</code>只统计数目 <code>-i</code> 忽略大小写查找</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>​    find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt;</p><h2 id="文件打包及解压缩"><a href="#文件打包及解压缩" class="headerlink" title="文件打包及解压缩"></a>文件打包及解压缩</h2><table><thead><tr><th align="center">文件后缀名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>*.zip</code></td><td align="center">zip 程序打包压缩的文件</td></tr><tr><td align="center"><code>*.rar</code></td><td align="center">rar 程序压缩的文件</td></tr><tr><td align="center"><code>*.7z</code></td><td align="center">7zip 程序压缩的文件</td></tr><tr><td align="center"><code>*.tar</code></td><td align="center">tar 程序打包，未压缩的文件</td></tr><tr><td align="center"><code>*.gz</code></td><td align="center">gzip 程序（GNU zip）压缩的文件</td></tr><tr><td align="center"><code>*.xz</code></td><td align="center">xz 程序压缩的文件</td></tr><tr><td align="center"><code>*.bz2</code></td><td align="center">bzip2 程序压缩的文件</td></tr><tr><td align="center"><code>*.tar.gz</code></td><td align="center">tar 打包，gzip 程序压缩的文件</td></tr><tr><td align="center"><code>*.tar.xz</code></td><td align="center">tar 打包，xz 程序压缩的文件</td></tr><tr><td align="center"><code>*tar.bz2</code></td><td align="center">tar 打包，bzip2 程序压缩的文件</td></tr><tr><td align="center"><code>*.tar.7z</code></td><td align="center">tar 打包，7z 程序压缩的文件</td></tr></tbody></table><h3 id="tar打包工具"><a href="#tar打包工具" class="headerlink" title="tar打包工具"></a>tar打包工具</h3><p><code>tar -zxvf</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown入门指南</title>
      <link href="/posts/2879.html"/>
      <url>/posts/2879.html</url>
      
        <content type="html"><![CDATA[<h1 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h1><p>Markdown是一种轻量级的标记语言，非常的简单，常用的符号不超过十个。</p><h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>​    <code># 一级标题</code></p><p>​    <code>## 二级标题</code></p><p>​    <code>### 三级标题</code></p><p>​    总共有六个标题</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>​    列表分为有序列表和无序列表</p><ul><li>无序列表<br><code>-</code> 或 <code>*</code></li><li>有序列表<br><code>1. 2. 3.</code></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>​    直接在文本前面加 <code>&gt;</code></p><h2 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h2><ul><li>图片 <code>![]()</code></li><li>链接 <code>[]()</code></li></ul><h2 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h2><p>​    用两个<code>**</code>来表示粗体</p><p>​    用一个<code>*</code>来表示斜体</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><h2 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h2><p>​    用``来包裹起来</p><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><p>​    三个<code>***</code> 来表示一个分割线</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git和github入门实践</title>
      <link href="/posts/f8de.html"/>
      <url>/posts/f8de.html</url>
      
        <content type="html"><![CDATA[<h2 id="Git与GitHub简介"><a href="#Git与GitHub简介" class="headerlink" title="Git与GitHub简介"></a>Git与GitHub简介</h2><h3 id="Git与GitHub的来历"><a href="#Git与GitHub的来历" class="headerlink" title="Git与GitHub的来历"></a>Git与GitHub的来历</h3><p>Linux 之父 Linus 在 1991 年创建开源的 Linux 操作系统之后，多年来依靠全世界广大热心志愿者的共同建设，经过长足发展，现已成为世界上最大的服务器系统。系统创建之初，代码贡献者将源码文件发送给 Linus，由其手动合并。这种方式维持多年后，代码量已经庞大到人工合并难以为继，于是深恶集中式版本控制系统的 Linus 选择了一个分布式商业版本控制系统 BitKeeper，不过 Linux 社区的建设者们可以免费使用它。BitKeeper 改变了 Linus 对版本控制的认识，同时 Linus 发现 BitKeeper 有一些不足，而且有个关键性的问题使之不能被广泛使用，就是不开源。</p><p>在 2005 年，BitKeeper 所在公司发现 Linux 社区有人企图破解它，BitKeeper 决定收回 Linux 社区的免费使用权。Linus 对此事调节数周无果，找遍了当时已知的各种版本控制系统，没有一个看上眼的，一怒之下决定自己搞一个。Linus 花了十天时间用 C 语言写好了一个开源的版本控制系统，就是著名的 Git。</p><p>2007 年旧金山三个年轻人觉得 Git 是个好东西，就搞了一个公司名字叫 GitHub，第二年上线了使用 Ruby 编写的同名网站 GitHub，这是一个基于 Git 的免费代码托管网站（有付费服务）。十年间，该网站迅速蹿红，击败了实力雄厚的 Google Code，成为全世界最受欢迎的代码托管网站。2018 年 6 月，GitHub 被财大气粗的 Microsoft 收购。2019 年 1 月 GitHub 宣布用户可以免费创建私有仓库。根据 2018 年 10 月的 GitHub 年度报告显示，目前有 3100 万开发者创建了 9600 万个项目仓库，有 210 万企业入驻。</p><h3 id="Git是用来干嘛的"><a href="#Git是用来干嘛的" class="headerlink" title="Git是用来干嘛的?"></a>Git是用来干嘛的?</h3><p>用来版本控制。通常我们修改了代码以后，发布新的版本以后，老版本是不可逆的，甚至多次修改可能会造成文件的混乱。这时，我们可以使用Git来进行控制，它可以方便的查看不同版本的不同之处，可以回退到老版本上。</p><h3 id="在GitHub上创建仓库"><a href="#在GitHub上创建仓库" class="headerlink" title="在GitHub上创建仓库"></a>在GitHub上创建仓库</h3><p>先要在GitHub上注册个人账户并登录。登录后在个人主页的右上角点击 <strong>New repository</strong>创建新的仓库。</p><p>填写<strong>Repository name</strong>后点击<strong>Create repository</strong></p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>在Windows系统，直接下载安装<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">GIt</a></p><h3 id="克隆GitHub上的仓库到本地"><a href="#克隆GitHub上的仓库到本地" class="headerlink" title="克隆GitHub上的仓库到本地"></a>克隆GitHub上的仓库到本地</h3><p>在仓库的主目录下，有一个隐藏的<code>.git</code>目录，它里面包含了仓库的全部信息，删掉这个目录，仓库就会变成普通的目录。使用命令行进入后，会发现出现(master),它就是当前所在的分支名。</p><p>当我们在GitHub上创建一个仓库时，同时生成了仓库的默认主机名origin,并创建了默认分钟master。GitHub可以看作是免费的Git服务器，在GitHub上创建仓库，会自动生成一个仓库地址，主机就是指代这个仓库。可通过执行<code>git remote -v</code>命令可以查看本地仓库所关联的远程仓库信息。</p><p>Git 要求对本地仓库关联的每个远程主机都必须指定一个主机名（默认为origin），用于本地仓库识别自己关联的主机，<code>git remote</code> 命令就用于管理本地仓库所关联的主机，一个本地仓库可以关联任意多个主机（即远程仓库）。</p><p>克隆远程仓库到本地时，还可以使用 <code>-o</code> 选项修改主机名，在地址后面加上一个字段作为本地仓库的主目录名。</p><p>常用命令<code>git init</code> ，它会把当前所在目录变成一个本地仓库，因为有GitHub,这个命令我们使用的次数应该为零。</p><h2 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h2><h3 id="Git仓库的三大区域"><a href="#Git仓库的三大区域" class="headerlink" title="Git仓库的三大区域"></a>Git仓库的三大区域</h3><p>Git本地仓库有三大区域：工作区、暂存区、版本区。</p><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://images2015.cnblogs.com/blog/809218/201606/809218-20160604213850274-1309981476.jpg" alt="img"></p><ul><li>工作区(workspace): 逻辑上是本地计算机，还没添加到repository的状态。</li><li>暂存区(stage): 即版本库中的stage,修改已经添加进repository，但是还没有作为commit提交，类似于缓存。</li><li>版本区(local repository),本地的版本区，到这一步，才算是成功的生成了一个新的版本。</li><li>远程仓库(Remote repository)</li></ul><h3 id="一次完成的修改、提交、推送操作"><a href="#一次完成的修改、提交、推送操作" class="headerlink" title="一次完成的修改、提交、推送操作"></a>一次完成的修改、提交、推送操作</h3><h4 id="简单来说"><a href="#简单来说" class="headerlink" title="简单来说"></a>简单来说</h4><p>第一步，用<code>git add</code>告诉Git,把文件添加到仓库中</p><p>第二步，用<code>git commit</code>告诉Git,把文件提交到仓库中</p><h4 id="具体来说"><a href="#具体来说" class="headerlink" title="具体来说"></a>具体来说</h4><p>首先，进入仓库主目录，执行git status查看整个仓库的状态。</p><p>当对文件进行增删改操作时，命令行会出现一个*星号。这表示工作区或暂存区有变化。</p><p>使用<code>git add [文件名]</code>命令跟踪此新建文件，即把新增文件添加到暂存区，以备提交。如果对多个文件或目录进行了增删改，可以使用<code>git add .</code>命令全部添加到暂存区。(当我们修改了工作区，git add命令是将这些修改田间到暂存区，暂存区记录的只是修改，如果要撤销暂存区的修改，执行<code>git reset -- [文件名]</code>或<code>git rm -- cached [文件名]</code> )</p><p>使用<code>git diff</code>，可以用来查看工作区被跟踪的文件的修改详情。使用git diff –cached查看暂存区的全部修改。</p><p>接下来，执行<code>git commit</code>命令，把暂存区的修改提交到版本区，生成一个新的版本。</p><p><code>git log</code> 用来查看版本区的提交历史记录。<code>git log [分支名]</code> 查看某分支的提交历史，不写分支名查看当前所在分支。<code>git log --oneline</code> 一行显示提交历史。<code>git log -n</code>其中n是数字，查看最近n个提交。<code>git log --author [贡献者名字]</code>查看指定贡献者的提交记录。<code>git log --graph</code>图示法显示提交历史。</p><p>接下来需要对Git进行一些本地配置。<code>git config -l user.email '注册邮箱'</code> <code>git config -l user.name</code> 完成后，系统会自动生成Git的配置文件。.gitconfig</p><p>提交暂存区的修改 <code>git commit -m '备注'</code> 提交后，暂存区的修改会被清空，执行<code>git log</code>可查看提交记录，其中有一个十六位的序列号为提交版本号。</p><p><code>git branch -avv</code> 查看所有的分支信息。会显示的信息为，开头的型号表示当前所在的分支，后面加的是版本号，再后为跟踪的远程分支的名字。最后一项是提交时填写的备注信息。</p><p>最后一个环节为，将本地新增的提交推送到GitHub远程仓库种，命令为<code>git push</code> ，执行完成后，可以通过<code>git branch -avv</code>查看分支情况。</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><h4 id="简单来说-1"><a href="#简单来说-1" class="headerlink" title="简单来说"></a>简单来说</h4><p>第一步，使用<code>git log</code>查看历史的版本号</p><p>第二步，使用<code>git reset --hard [版本号或者是^]</code>回退版本</p><p>可以使用<code>git reflog</code>来查看每一次的命令，从而找到刚才回退前的版本号，从而实现可再回到新的版本上。</p><h4 id="具体来说-1"><a href="#具体来说-1" class="headerlink" title="具体来说"></a>具体来说</h4><p>首先执行<code>git reset --soft HEAD^</code> 撤销最近的一次提交，将修改还原到暂存区。<code>--soft</code>表示软退回，对应的还有<code>--hard</code>硬退回，后面会讲到。<code>HEAD</code>表示撤回一次提交，<code>HEAD^^</code>表示撤销两次提交，撤销n次提交可以简写为<code>HEAD~n</code>。软退回一个提交后执行<code>git branch -avv</code>命令查看分支信息，然后可以看到本地仓库的master分支的版本号已经发生了变化，变成了前一个提交的版本号。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><h4 id="对工作区的撤销"><a href="#对工作区的撤销" class="headerlink" title="对工作区的撤销"></a>对工作区的撤销</h4><p><code>git checkout -- file</code> 可以丢弃工作区的修改，使它回到最近的一个<code>git commit</code>或<code>git add</code>时的状态</p><h4 id="对暂存区的撤销"><a href="#对暂存区的撤销" class="headerlink" title="对暂存区的撤销"></a>对暂存区的撤销</h4><p><code>git reset HEAD &lt;file&gt;</code> 把暂存区的修改撤销掉，重新放回工作区</p><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><h3 id="GitHub基本配置"><a href="#GitHub基本配置" class="headerlink" title="GitHub基本配置"></a>GitHub基本配置</h3><p>第一步：创建SSH Key。<code>ssh-keygen -t rsa -C "youremail@example.com"</code> 。在用户主目录下找到<code>.ssh</code>隐藏文件夹。其中有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，<code>id_rsa</code>为私钥，<code>id_rsa.pub</code>为公钥。</p><p>第二步：登录GitHub，打开Account Setting，添加SSH Key，将公钥内容添加到里面。</p><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>第一步：登录GitHub，在右上角选择<code>Create a new repo</code>,新建一个仓库。</p><p>第二步：与本地仓库进行关联，在本地仓库运行<code>git remote add origin [地址]</code> 添加后，远程库的名字就叫origin</p><p>第三步：将本地仓库的内容推送到远程仓库中。<code>git push -u origin master</code> 第一次推动master分支时，加上-u参数，目的是将本地master 和远程的master进行关联。以后在进行推送时，只需要输入<code>git push origin master</code></p><h3 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h3><p><code>git clone [地址]</code> 从远程仓库中将代码克隆下来</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p><p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>第一步：创建dev分支，并切换到dev分支 <code>git checkout -b dev</code> 其中<code>-b</code>是用来创建分支的。</p><p>第二步：使用<code>git branch</code>会列出所有的分支，当前分支前面会有一个星号。</p><p>第三步：合并分支。使用<code>git merge [分支名]</code> 将指定分支合并到当前分支。</p><p>第四步：删除分支。使用<code>git checkout -d dev</code> 删除分支</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
